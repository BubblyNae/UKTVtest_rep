# UKTVtest_rep
My source files for the UKTV Software Developer Interview Task

## Intro
Hello! Before talking about some of my decisions on the task, just want to add a few asterisks to the project because the circumstances of the project are rough.

There are a few things that I've rushed in the project (and I mention this a few times in the comments). I was very low on time due to complications in getting the interview task, so I didn't have as much time to polish some stuff that I'd really like to. This is also the reason for functionality around adding singular entries to the "Search Results" page. The wording on the pdf was a little confusing to me, and with more time I would have double checked with you to see whether the user should only be able to add to the results page via searching for "Result Categories" or if the user should be able to search for anything within the 3 categories. I decided to include the functionality, but have seperated it from the logic of searching for "categories".

## Structure
Since a big criteria of the task was flexibility for the purposes of expanding in the future. With this in mind, I wanted to do modular, MVVM architecture, so more functions can be added to this feature specifically through new use_cases and expansions on the repository, or new features can be added to app as a whole without impacting the current SWAPI feature. The use of an interface for the repository, as well as the repository design structure allows for multiple ways of accessing data sources. This is useful for reducing unnecessary API calls by making "Test" repositories, or making new repositories if new data sources are implemented into the feature (such as accessing a database rather than an API call). I will add an extra note here that while I'm pretty familiar with kotlin I haven't used it in a while, so this task also served as a crash course on using compose. I think I've done a pretty good job with picking it up, but of course it's probably something to polish up on the job.

## Summary
The app resolves around 2 screens, the SearchScreen and the ResultsScreen. The app starts on the SearchScreen, and the SearchViewModel contains the logic behind the composable methods within the SearchScreen. 

### Search Screen
When the SearchScreen is opened, if the repository doesn't contain the locally cached entries from the API, the API is called, and all of the local values that will store the entries of the current session are populated. On the SearchScreen, there is a TextField with custom logic to show a hint when the user hasn't input text into the field. It also includes a button, that when pressed will look through the locally cached results in the repository, and either return all entries related to the user's entry if they input "vehicles", "films" and "starships", returns a single entry based on the first result that matches the user's input or prints an error using a Snackbox so the user can see the feature isn't working and can try a different solution. There's a method that checks the user's input so "starships", "ships" and "starship" are still valid results for returning "starship" results. If results are returned, these results are added to a different local value that keeps track of all the entries the user has entered. The ResultsScreen is then opened.

### Result Screen
When the ResultsScreen is opened, the currently searched results are retrieved from the repository, and then added to the Search Screen, with different coloured cards for the 3 categories of result. The results can be sorted, ascending or descending by the "reference" of each result ("name" for vehicle and starships, and "title" for films). To access this feature, the user can press the button on the top right, which drops down a small panel containing the ordering functions, and press it again to hide the menu. There's also a button to clear the results the user has searched. If this button or the "X" button on the top left are pressed, the user will return to the Search Screen. 

## Dependency Injection
Hilt-Dagger is maybe a little much for a quick test task, but I think it's crucial for making expansion easier to manage. Koin might've been better for *super* long-term application development, especially for low-power android devices (like some Smart TVs), but also some of the use cases where Hilt-Dagger isn't possible to use aren't really applicable for Smart TVs (i.e. systems that allow you to download individual modules for an application). Manual DI is probably the best call, considering the control at a large scale, but the boiler plate with my limited time was a bit unrealistic.